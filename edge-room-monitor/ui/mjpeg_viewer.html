<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Edge Room Monitor - Tap to Track</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: sans-serif;
      background: #1e1b23;
      color: #f7f1ff;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 20px;
    }

    h1 {
      font-size: 24px;
    }

    #info {
      background: #2a2630;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 14px;
    }

    #container {
      position: relative;
      border: 2px solid #9480ff;
      border-radius: 6px;
      overflow: hidden;
      background: #000;
    }

    #stream {
      display: block;
      max-width: 90vw;
      max-height: 70vh;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: pointer;
    }

    .status {
      background: #2a2630;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 12px;
    }

    .selected {
      color: #4ade80;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <h1>ğŸ¯ Tap to Track - äººç‰©è¿½è·¡</h1>
  <div id="info">
    <div>ğŸ“¹ ã‚¹ãƒˆãƒªãƒ¼ãƒ : <span id="stream-status">æ¥ç¶šä¸­...</span></div>
    <div>ğŸ‘¤ é¸æŠä¸­: <span id="selected-status" class="selected">ãªã—</span></div>
    <div>ğŸ’¡ ä½¿ã„æ–¹: äººç‰©ã®ãƒœãƒƒã‚¯ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¿½è·¡é–‹å§‹/è§£é™¤</div>
  </div>
  <div id="container">
    <img id="stream" alt="MJPEG stream" />
    <canvas id="canvas"></canvas>
  </div>
  <div class="status">
    æ¤œå‡ºæ•°: <span id="detection-count">0</span> äºº
  </div>

  <script>
    const API_BASE = window.location.origin;
    const STREAM_URL = `${API_BASE}/stream`;
    const DETECTIONS_URL = `${API_BASE}/api/detections`;
    const SELECT_URL = `${API_BASE}/api/select`;
    const UNSELECT_URL = `${API_BASE}/api/unselect`;

    const stream = document.getElementById('stream');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let detections = [];
    let selectedTrackingId = null;
    let streamWidth = 640;
    let streamHeight = 480;

    // ã‚¹ãƒˆãƒªãƒ¼ãƒ èª­ã¿è¾¼ã¿
    stream.src = STREAM_URL;
    stream.onload = () => {
      document.getElementById('stream-status').textContent = 'æ¥ç¶šæ¸ˆã¿ âœ“';
      updateCanvasSize();
    };
    stream.onerror = () => {
      document.getElementById('stream-status').textContent = 'æ¥ç¶šã‚¨ãƒ©ãƒ¼ âœ—';
    };

    // Canvas ã‚µã‚¤ã‚ºèª¿æ•´
    function updateCanvasSize() {
      canvas.width = stream.clientWidth;
      canvas.height = stream.clientHeight;
      streamWidth = stream.naturalWidth || 640;
      streamHeight = stream.naturalHeight || 480;
    }
    window.addEventListener('resize', updateCanvasSize);

    // æ¤œå‡ºæƒ…å ±ã‚’å®šæœŸå–å¾—
    async function fetchDetections() {
      try {
        const response = await fetch(DETECTIONS_URL);
        const data = await response.json();
        detections = data.detections || [];
        document.getElementById('detection-count').textContent = detections.length;
        drawBoundingBoxes();
      } catch (error) {
        console.error('Failed to fetch detections:', error);
      }
    }

    // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æç”»
    function drawBoundingBoxes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const scaleX = canvas.width / streamWidth;
      const scaleY = canvas.height / streamHeight;

      detections.forEach(det => {
        const x = det.bbox.left * scaleX;
        const y = det.bbox.top * scaleY;
        const w = det.bbox.width * scaleX;
        const h = det.bbox.height * scaleY;

        const isSelected = det.tracking_id === selectedTrackingId;

        // ãƒœãƒƒã‚¯ã‚¹æç”»
        ctx.strokeStyle = isSelected ? '#00ff00' : '#ff0000';
        ctx.lineWidth = isSelected ? 6 : 3;
        ctx.strokeRect(x, y, w, h);

        // ãƒ©ãƒ™ãƒ«èƒŒæ™¯
        const label = isSelected
          ? `ğŸ‘¤ è¿½è·¡ä¸­ ID:${det.tracking_id}`
          : `ID:${det.tracking_id} (ã‚¿ãƒƒãƒ—)`;
        ctx.font = isSelected ? 'bold 20px sans-serif' : 'bold 16px sans-serif';
        const textWidth = ctx.measureText(label).width;

        ctx.fillStyle = isSelected ? '#00ff00' : '#ff0000';
        ctx.fillRect(x, y - 30, textWidth + 16, 30);

        // ãƒ©ãƒ™ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ
        ctx.fillStyle = '#000000';
        ctx.fillText(label, x + 8, y - 8);

        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
        const debugLabel = `conf:${det.confidence.toFixed(2)}`;
        ctx.font = '14px sans-serif';
        ctx.fillStyle = isSelected ? '#00ff00' : '#ff0000';
        ctx.fillRect(x, y + h - 24, 100, 24);
        ctx.fillStyle = '#000000';
        ctx.fillText(debugLabel, x + 4, y + h - 6);
      });
    }

    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    canvas.addEventListener('click', async (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      console.log(`Click at: ${clickX}, ${clickY}`);

      const scaleX = canvas.width / streamWidth;
      const scaleY = canvas.height / streamHeight;

      // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸãƒœãƒƒã‚¯ã‚¹ã‚’æ¢ã™
      for (const det of detections) {
        const x = det.bbox.left * scaleX;
        const y = det.bbox.top * scaleY;
        const w = det.bbox.width * scaleX;
        const h = det.bbox.height * scaleY;

        console.log(`Checking bbox: x=${x}, y=${y}, w=${w}, h=${h}, id=${det.tracking_id}`);

        if (clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h) {
          console.log(`HIT! Toggling ID: ${det.tracking_id}`);
          await toggleSelection(det.tracking_id);
          return;
        }
      }
      console.log('No bbox clicked');
    });

    // é¸æŠ/è§£é™¤ãƒˆã‚°ãƒ«
    async function toggleSelection(trackingId) {
      console.log(`toggleSelection called with ID: ${trackingId}, current selected: ${selectedTrackingId}`);

      if (selectedTrackingId === trackingId) {
        // è§£é™¤
        console.log('Unselecting...');
        try {
          const response = await fetch(UNSELECT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tracking_id: trackingId })
          });
          const result = await response.json();
          console.log('Unselect response:', result);
          selectedTrackingId = null;
          document.getElementById('selected-status').textContent = 'ãªã—';
        } catch (error) {
          console.error('Failed to unselect:', error);
        }
      } else {
        // é¸æŠ
        console.log('Selecting...');
        try {
          const response = await fetch(SELECT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tracking_id: trackingId })
          });
          const result = await response.json();
          console.log('Select response:', result);
          selectedTrackingId = trackingId;
          document.getElementById('selected-status').textContent = `ID: ${trackingId}`;
        } catch (error) {
          console.error('Failed to select:', error);
        }
      }
      drawBoundingBoxes();
    }

    // å®šæœŸæ›´æ–°é–‹å§‹
    setInterval(fetchDetections, 100); // 100ms = 10fps
    fetchDetections();
  </script>
</body>

</html>