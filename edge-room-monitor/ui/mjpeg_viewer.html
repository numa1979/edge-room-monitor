<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Edge Room Monitor - Tap to Track</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: sans-serif;
      background: #1e1b23;
      color: #f7f1ff;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 20px;
    }

    h1 {
      font-size: 24px;
    }

    #info {
      background: #2a2630;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 14px;
    }

    #container {
      position: relative;
      border: 2px solid #9480ff;
      border-radius: 6px;
      overflow: hidden;
      background: #000;
    }

    #stream {
      display: block;
      max-width: 90vw;
      max-height: 70vh;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: pointer;
    }

    .status {
      background: #2a2630;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 12px;
    }

    .selected {
      color: #4ade80;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <h1>ğŸ¯ Tap to Track - äººç‰©è¿½è·¡</h1>
  <div id="info">
    <div>ğŸ“¹ ã‚¹ãƒˆãƒªãƒ¼ãƒ : <span id="stream-status">æ¥ç¶šä¸­...</span></div>
    <div>ğŸ‘¤ é¸æŠä¸­: <span id="selected-status" class="selected">ãªã—</span></div>
    <div>ğŸ’¡ ä½¿ã„æ–¹: äººç‰©ã®ãƒœãƒƒã‚¯ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¿½è·¡é–‹å§‹/è§£é™¤</div>
  </div>
  <div id="container">
    <img id="stream" alt="MJPEG stream" />
    <canvas id="canvas"></canvas>
  </div>
  <div class="status">
    æ¤œå‡ºæ•°: <span id="detection-count">0</span> äºº
  </div>

  <script>
    const API_BASE = window.location.origin;
    const STREAM_URL = `${API_BASE}/stream`;
    const DETECTIONS_URL = `${API_BASE}/api/detections`;
    const REGISTER_URL = `${API_BASE}/api/register`;
    const UNREGISTER_URL = `${API_BASE}/api/unregister`;

    const stream = document.getElementById('stream');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let detections = [];
    let streamWidth = 640;
    let streamHeight = 480;

    const COLORS = ['#00ff00', '#00ffff', '#ffff00', '#ff00ff'];  // å›ºå®šID 0-3ã®è‰²

    // ã‚¹ãƒˆãƒªãƒ¼ãƒ èª­ã¿è¾¼ã¿
    stream.src = STREAM_URL;
    stream.onload = () => {
      document.getElementById('stream-status').textContent = 'æ¥ç¶šæ¸ˆã¿ âœ“';
      updateCanvasSize();
    };
    stream.onerror = () => {
      document.getElementById('stream-status').textContent = 'æ¥ç¶šã‚¨ãƒ©ãƒ¼ âœ—';
    };

    // Canvas ã‚µã‚¤ã‚ºèª¿æ•´
    function updateCanvasSize() {
      canvas.width = stream.clientWidth;
      canvas.height = stream.clientHeight;
      streamWidth = stream.naturalWidth || 640;
      streamHeight = stream.naturalHeight || 480;
    }
    window.addEventListener('resize', updateCanvasSize);

    // æ¤œå‡ºæƒ…å ±ã‚’å®šæœŸå–å¾—
    async function fetchDetections() {
      try {
        const response = await fetch(DETECTIONS_URL);
        const data = await response.json();
        detections = data.detections || [];

        // ç™»éŒ²æ¸ˆã¿äººæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        const registeredCount = detections.filter(d => d.registered).length;
        document.getElementById('detection-count').textContent = detections.length;
        document.getElementById('selected-status').textContent =
          registeredCount > 0 ? `${registeredCount}äººç™»éŒ²ä¸­` : 'ãªã—';

        drawBoundingBoxes();
      } catch (error) {
        console.error('Failed to fetch detections:', error);
      }
    }

    // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æç”»
    function drawBoundingBoxes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const scaleX = canvas.width / streamWidth;
      const scaleY = canvas.height / streamHeight;

      detections.forEach(det => {
        const x = det.bbox.left * scaleX;
        const y = det.bbox.top * scaleY;
        const w = det.bbox.width * scaleX;
        const h = det.bbox.height * scaleY;

        const isRegistered = det.registered;
        const color = isRegistered ? COLORS[det.fixed_id % COLORS.length] : '#ff0000';

        // ãƒœãƒƒã‚¯ã‚¹æç”»
        ctx.strokeStyle = color;
        ctx.lineWidth = isRegistered ? 6 : 3;
        ctx.strokeRect(x, y, w, h);

        // ãƒ©ãƒ™ãƒ«èƒŒæ™¯
        const label = isRegistered
          ? `ğŸ‘¤ ID:${det.fixed_id} (è¿½è·¡ä¸­)`
          : `nvID:${det.nvtracker_id} (ã‚¿ãƒƒãƒ—ã§ç™»éŒ²)`;
        ctx.font = isRegistered ? 'bold 20px sans-serif' : 'bold 16px sans-serif';
        const textWidth = ctx.measureText(label).width;

        ctx.fillStyle = color;
        ctx.fillRect(x, y - 30, textWidth + 16, 30);

        // ãƒ©ãƒ™ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ
        ctx.fillStyle = '#000000';
        ctx.fillText(label, x + 8, y - 8);

        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
        const debugLabel = isRegistered
          ? `nvID:${det.nvtracker_id}`
          : `conf:${det.confidence.toFixed(2)}`;
        ctx.font = '14px sans-serif';
        ctx.fillStyle = color;
        const debugWidth = ctx.measureText(debugLabel).width;
        ctx.fillRect(x, y + h - 24, debugWidth + 8, 24);
        ctx.fillStyle = '#000000';
        ctx.fillText(debugLabel, x + 4, y + h - 6);
      });
    }

    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    canvas.addEventListener('click', async (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      console.log(`Click at: ${clickX}, ${clickY}`);

      const scaleX = canvas.width / streamWidth;
      const scaleY = canvas.height / streamHeight;

      // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸãƒœãƒƒã‚¯ã‚¹ã‚’æ¢ã™
      for (const det of detections) {
        const x = det.bbox.left * scaleX;
        const y = det.bbox.top * scaleY;
        const w = det.bbox.width * scaleX;
        const h = det.bbox.height * scaleY;

        if (clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h) {
          console.log(`HIT! nvtracker_id=${det.nvtracker_id}, fixed_id=${det.fixed_id}, registered=${det.registered}`);
          await toggleRegistration(det);
          return;
        }
      }
      console.log('No bbox clicked');
    });

    // ç™»éŒ²/è§£é™¤ãƒˆã‚°ãƒ«
    async function toggleRegistration(det) {
      if (det.registered) {
        // ç™»éŒ²è§£é™¤
        console.log(`Unregistering Fixed ID ${det.fixed_id}...`);
        try {
          const response = await fetch(UNREGISTER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fixed_id: det.fixed_id })
          });
          const result = await response.json();
          console.log('Unregister response:', result);
        } catch (error) {
          console.error('Failed to unregister:', error);
        }
      } else {
        // ç™»éŒ²
        console.log(`Registering nvtracker_id ${det.nvtracker_id}...`);
        try {
          const response = await fetch(REGISTER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ nvtracker_id: det.nvtracker_id })
          });
          const result = await response.json();
          console.log('Register response:', result);
        } catch (error) {
          console.error('Failed to register:', error);
        }
      }
      // ã™ãã«æ›´æ–°
      await fetchDetections();
    }

    // å®šæœŸæ›´æ–°é–‹å§‹
    setInterval(fetchDetections, 100); // 100ms = 10fps
    fetchDetections();
  </script>
</body>

</html>